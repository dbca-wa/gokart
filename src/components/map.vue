<template>
  <div class="map" id="map" tabindex="0">
    <gk-info v-ref:info></gk-info>
  </div>
  <gk-scales v-ref:scales></gk-scales>
  <gk-search v-ref:search></gk-search>
  <gk-measure v-ref:measure></gk-measure>
</template>

<script>
  import { $, ol, proj4, moment,momentTimezone } from 'src/vendor.js'
  import gkInfo from './info.vue'
  import gkScales from './scales.vue'
  import gkSearch from './search.vue'
  import gkMeasure from './measure.vue'
  export default {
    store: ['defaultWMTSSrc', 'defaultWFSSrc', 'gokartService', 'fixedScales', 'resolutions', 'matrixSets', 'dpmm', 'view'],
    components: { gkInfo, gkScales, gkSearch, gkMeasure },
    data: function () {
      return {
        scale: 0,
        mapControls:{},
        graticule: new ol.LabelGraticule(),
        dragPanInter: new ol.interaction.DragPan({
          condition: function (mapBrowserEvent) {
            if (mapBrowserEvent.pointerEvent && (mapBrowserEvent.pointerEvent.button === 1)) {
              return false
            }
            return ol.events.condition.noModifierKeys(mapBrowserEvent)
          }
        }),
        doubleClickZoomInter: new ol.interaction.DoubleClickZoom(),
        keyboardPanInter: new ol.interaction.KeyboardPan(),
        keyboardZoomInter: new ol.interaction.KeyboardZoom(),
        middleDragPanInter: new ol.interaction.DragPan({
          condition: function (mapBrowserEvent) {
            if (mapBrowserEvent.pointerEvent && (mapBrowserEvent.pointerEvent.button === 1)) {
              mapBrowserEvent.preventDefault()
              return true
            }
            return false
          }
        })
      }
    },
    // parts of the template to be computed live
    computed: {
      loading: function () { return this.$root.loading },
      annotations: function () { return this.$root.annotations    },
      active: function () { return this.$root.active    },
      measure: function () { return this.$root.measure    },
      // because the viewport size changes when the tab pane opens, don't cache the map width and height
      width: {
        cache: false,
        get: function get () {
          return $("#map").width()
        }
      },
      height: {
        cache: false,
        get: function get () {
          return $("#map").height()
        }
      },
      extent: function() {
        return this.olmap.getView().calculateExtent(this.olmap.getSize())
      },
      resolution:function() {
        return this.olmap.getView().getResolution()
      }
    },
    // methods callable from inside the template
    methods: {
      //enable or disable a control
      enableControl:function(controlName,enable) {
        var vm = this
        var control = this.mapControls[controlName]
        if (!control || control.enabled === enable) {
            //already enabled or disabled
            return
        }
        if (control.controls) {
            if (Array.isArray(control.controls)) {
                $.each(control.controls,function(index,c){
                    if (enable) {
                        vm.olmap.addControl(c)
                    } else {
                        vm.olmap.removeControl(c)
                    }
                })
            } else {
                if (enable) {
                    vm.olmap.addControl(control.controls)
                } else {
                    vm.olmap.removeControl(control.controls)
                }
            }
        }
        control.enabled = enable
      },
      editResource: function(event) {
        var target = (event.target.nodeName == "A")?event.target:event.target.parentNode;
        if (env.appType == "cordova") {
            window.open(target.href,"_system");
        } else {
            window.open(target.href,target.target);
        }
      },
      tintSVG: function(svgstring, tints) {
        tints.forEach(function(colour) {
          svgstring = svgstring.split(colour[0]).join(colour[1])
        })
        return svgstring
      },
      //keys:[url,tint?,dims?]
      getBlob: function(feature, keys,tintSettings,callback) {
        // method to precache SVGs as raster (PNGs)
        // workaround for Firefox missing the SurfaceCache when blitting to canvas
        // returns a url or undefined if svg isn't baked yet
        var vm = this
        var tool = feature.get('toolName')?vm.annotations.getTool(feature.get('toolName')):{}
        var key = keys.map(function(k) {
          return vm.annotations.getStyleProperty(feature,k,'default',tool)
        }).join(";")
        if (this.svgBlobs[key]) {
          return this.svgBlobs[key]
        } else if (this.jobs[key]) {
          vm.jobs[key].then(function(){
                feature.changed()
                if (callback) {callback()}
          })
        } else {
          var dimsKey = (keys.length >= 3)?keys[2]:'dims'
          var tintKey = (keys.length >= 2)?keys[1]:'tint'

          var dims = tool[dimsKey] || [48, 48]
          var tint = vm.annotations.getStyleProperty(feature,tintKey,'default',tool)
          if (!Array.isArray(tint)) {
              //tint is a named tint,get the tint setting from tints object
              tint = (tintSettings && tintSettings[tint])?tintSettings[tint]:[]
          }
          var url = vm.annotations.getStyleProperty(feature,keys[0],null,tool)
          if (typeof tint === "string") {
            //tint is not just a color replacement, is a totally different icon
            url = tint
            tint = []
          }
          vm.jobs[key] = new Promise(function(resolve, reject) {
            vm.addSVG(key, url, tint, dims, resolve)
          }).then(function() {
            feature.changed()
            delete vm.jobs[key]
            if (callback) {callback()}
          })
        }


      },
      addSVG: function(key, url, tint, dims, pResolve) {
        var vm = this
        tint = tint || []
        var draw = function() {
          if (typeof vm.svgBlobs[key] !== 'undefined') { pResolve() }
          // RACE CONDITION: MS edge inlines promises and callbacks!
          // we can't set vm.svgBlobs[key] to be the Promise, as
          // it's entirely possible for the whole thing to have been 
          // completed in the constructor before the svgBlobs array is even set
          //vm.svgBlobs[key] = ''
          var drawJob = new Promise(function(resolve, reject) {
            vm.drawSVG(key, vm.svgTemplates[url], tint, dims, resolve, reject)
          }).then(function() {
            pResolve()
          })
        }
        if (vm.svgTemplates[url]) {
          // render from loaded svg or queue render post load promise
          draw()
        } else if (vm.jobs[url]) {
            vm.jobs[url].then(function(){
                draw()
            })
        } else {
          vm.jobs[url] = new Promise(function (resolve, reject) { 
            // load svg
            //console.log('addSVG: Cache miss for '+key)
            var req = new window.XMLHttpRequest()
            req.withCredentials = true
            req.onload = function () {
              if (!this.responseText) {
                return
              }
              //console.log('addSVG: XHR returned for '+key)
              vm.svgTemplates[url] = this.responseText
              resolve()
            }
            req.onerror = function() {
              reject()
            }
            req.open('GET', url)
            req.send()
          }).then(function(){
            draw()
            delete vm.jobs[url]
          })
        }
      },
      drawSVG: function(key, svgstring, tints, dims, resolve, reject) {
        var vm = this
        //console.log('drawSVG: Cache miss for '+key)
        var canvas = $('<canvas>')
        canvas.attr({width: dims[0], height: dims[1]})
        canvas.drawImage({
          source: 'data:image/svg+xml;utf8,' + encodeURIComponent(vm.tintSVG(svgstring, tints)),
          fromCenter: false, x: 0, y: 0, width: dims[0], height: dims[1],
          load: function () {
            //console.log('drawSVG: Canvas drawn for '+key)
            canvas.get(0).toBlob(function (blob) {
              vm.svgBlobs[key] = window.URL.createObjectURL(blob)
              //console.log("drawSVG:" + key + "\t url = " + vm.svgBlobs[key])
              resolve()
            }, 'image/png')
          }
        })
      },
      cacheStyle: function(styleFunc, feature, keys) {
        var vm = this
        if (feature) {
            var key = keys.map(function(k) {
              return vm.annotations.getStyleProperty(feature,k,'default')
            }).join(";")
            var style = this.cachedStyles[key]
            if (style) { 
                return style 
            }
            style = styleFunc(feature)
            if (style) {
              this.cachedStyles[key] = style
              return style
            }
        }
        return new ol.layer.Vector().getStyleFunction()()
      },
      animatePan: function (location) {
        // pan from the current center
        var pan = ol.animation.pan({
          source: this.getCenter()
        })
        this.olmap.beforeRender(pan)
        // when we set the new location, the map will pan smoothly to it
        this.olmap.getView().setCenter(location)
      },
      animateZoom: function (resolution) {
        // zoom from the current resolution
        var zoom = ol.animation.zoom({
          resolution: this.olmap.getView().getResolution()
        })
        this.olmap.beforeRender(zoom)
        // setting the resolution to a new value will smoothly zoom in or out
        // depending on the factor
        this.olmap.getView().setResolution(resolution)
      },
      // force OL to approximate a fixed scale (1:1K increments)
      setScale: function (scale) {
        while (Math.abs(this.getScale() - scale) > 0.001) {
          this.olmap.getView().setResolution(this.olmap.getView().getResolution() * scale / this.getScale())
        }
        this.scale = scale
      },
      // return the scale (1:1K increments)
      getScale: function () {
        var size = this.olmap.getSize()
        var center = this.getCenter()
        var extent = this.olmap.getView().calculateExtent(size)
        var distance = this.$root.wgs84Sphere.haversineDistance([extent[0], center[1]], center) * 2
        return distance * this.dpmm / size[0]
      },
      // get the fixed scale (1:1K increments) closest to specified or the current scale
      getFixedScale: function (scale) {
        scale = scale || this.getScale()
        var closest = null
        $.each(this.fixedScales, function () {
          if (closest === null || Math.abs(this - scale) < Math.abs(closest - scale)) {
            closest = this
          }
        })
        return closest
      },
      // generate a human-readable scale string
      getScaleString: function (scale) {
        if (Math.round(scale * 100) / 100 < 10.0) {
          return '1:' + (Math.round(scale * 1000)).toLocaleString()
        } else if (Math.round(scale * 100) / 100 >= 1000.0) {
          return '1:' + (Math.round(scale / 1000)).toLocaleString() + ' M'
        }
        return '1:' + (Math.round(scale)).toLocaleString() + ' K'
      },
      // get the decimal degrees representation of some EPSG:4326 coordinates
      getDeg: function(coords) {
        return coords[0].toFixed(5)+', '+coords[1].toFixed(5)
      },
      // get the DMS representation of some EPSG:4326 coordinates
      getDMS: function(coords) {
        return ol.coordinate.degreesToStringHDMS_(coords[0], 'EW', 1) + ', ' +
               ol.coordinate.degreesToStringHDMS_(coords[1], 'NS', 1)
      },
      // get the MGA representation of some EPSG:4326 coordinates
      getMGA: function(coords) {
        var mga = this.getMGARaw(coords)
        if (mga) {
            return 'MGA '+mga.mgaZone+' '+Math.round(mga.mgaEast)+'E '+Math.round(mga.mgaNorth)+'N'
        }
        return ''
      },
      getMGARaw: function(coords) {
        var results = {}
        if ((coords[0] >= 108) && (coords[0] < 114)) {
          results.mgaZone = 49
        } else if ((coords[0] >= 114) && (coords[0] < 120)) {
          results.mgaZone = 50
        } else if ((coords[0] >= 120) && (coords[0] < 126)) {
          results.mgaZone = 51
        } else if ((coords[0] >= 126) && (coords[0] < 132)) {
          results.mgaZone = 52
        } else if ((coords[0] >= 132) && (coords[0] < 138)) {
          results.mgaZone = 53
        } else if ((coords[0] >= 138) && (coords[0] < 144)) {
          results.mgaZone = 54
        } else if ((coords[0] >= 144) && (coords[0] < 150)) {
          results.mgaZone = 55
        } else if ((coords[0] >= 150) && (coords[0] < 156)) {
          results.mgaZone = 56
        } else {
          // fail if not in the bounding box for MGA
          return null
        }
        var newCoords = proj4('EPSG:4326', 'EPSG:283'+results.mgaZone).forward(coords)
        results.mgaEast = newCoords[0]
        results.mgaNorth = newCoords[1]
        return results
      },
      // parse a string containing coordinates in decimal or DMS format
      parseDMSString: function(dmsStr) {
        // https://regex101.com/r/kS2zR1/22
        var dmsRegex = /^\s*(-)?(\d+(?:\.\d+)?)[°º:d\s]?\s*(?:(\d+(?:\.\d+)?)['’‘′:m]\s*(?:(\d{1,2}(?:\.\d+)?)(?:"|″|’’|''|s)?)?)?\s*([NSEW])?[,:\s]+(-)?(\d+(?:\.\d+)?)[°º:d\s]?\s?(?:(\d+(?:\.\d+)?)['’‘′:m]\s*(?:(\d{1,2}(?:\.\d+)?)(?:"|″|’’|''|s)?)?)?\s*([NSEW])?$/gmi
        
        var groups = dmsRegex.exec(dmsStr)

        if (!groups) {
          return null
        }

        var dmsToDecimal = function(sign, deg, min, sec, dir) {
          var sg = sign ? -1 : 1
          sg = sg * (('wWsS'.indexOf(dir) >= 0) ? -1 : 1)
          var d = Number(deg)
          var m = min ? Number(min) : 0
          var s = sec ? Number(sec) : 0
          if (!(d >= 0 && d <= 180)) return null
          if (!(m >= 0 && m <= 60)) return null
          if (!(s >= 0 && s <= 60)) return null
          return sg*(d+(m/60)+(s/3600))
        }

        var coords = [
          dmsToDecimal(groups[1], groups[2], groups[3], groups[4], groups[5]),
          dmsToDecimal(groups[6], groups[7], groups[8], groups[9], groups[10])
        ]

        if ((!coords[0]) || (!coords[1])) {
          // one coordinate fails the sniff test
          return null
        }

        // order most people use is northing, easting (opposite of EPSG:4326)
        if (!groups[5] && !groups[10]) {
            coords = coords.reverse()
        // if only one is explicitly defined, swap if required
        } else if (!groups[5] || !groups[10]) {
          if (groups[5] && ('nNsS'.indexOf(groups[5]) >=0)) {
            coords = coords.reverse()
          } else if (groups[10] && ('wWeE'.indexOf(groups[10]) >=0)) {
            coords = coords.reverse()
          }
        // both are explicitly defined
        } else {
          // bomb out if someone describes two of the same
          if (('nNsS'.indexOf(groups[5]) >=0) && ('nNsS'.indexOf(groups[10]) >=0)) {
            return null
          } else if (('wWeE'.indexOf(groups[5]) >=0) && ('wWeE'.indexOf(groups[10]) >=0)) {
            return null
          }
          // swap if defined around the other way
          if (('nNsS'.indexOf(groups[5]) >=0) && ('wWeE'.indexOf(groups[10]) >=0)) {
            coords = coords.reverse()
          }
        }
        return coords 
      },
      // parse a string containing coordinates in MGA grid reference format
      // e.g. MGA 51 340000 6340000, MGA 51 340000mE 6340000mN, MGA 51 3406340
      parseMGAString: function(mgaStr) {
        // https://regex101.com/r/zY8dW4/2
        var mgaRegex = /(?:MGA|mga)\s*(49|50|51|52|53|54|55|56)\s*(\d{3,7})\s*[mM]{0,1}\s*([nNeE]{0,1})\s*,*\s*(\d{4,7})\s*[mM]{0,1}\s*([nNeE]{0,1})/gi
        var groups = mgaRegex.exec(mgaStr)
        
        if (!groups) {
          return null
        }

        var results = {
          mgaZone: parseInt(groups[1]),
          mgaEast: groups[2],
          mgaNorth: groups[4],
        }
        if ((groups[5] === "E") && (groups[3] === "N")) {
          results.mgaEast = groups[4]
          results.mgaNorth = groups[2]
        }
        if ((results.mgaEast.length === 3) && (results.mgaNorth.length === 4)) {
          results.mgaEast = results.mgaEast + '000'
          results.mgaNorth = results.mgaNorth + '000'
        } else if ((results.mgaEast.length === 6) && (results.mgaNorth.length === 7)) {
          // full length MGA coords
        } else {
          return null  // invalid MGA length
        }
        results.mgaEast = parseInt(results.mgaEast)
        results.mgaNorth = parseInt(results.mgaNorth)

        var coords = proj4('EPSG:283'+groups[1], 'EPSG:4326').forward([results.mgaEast, results.mgaNorth])
        results.coords = coords
        
        return results
      },
      // parse a string containing a FD Grid reference
      parseGridString: function(fdStr) {
        var fdRegex = /(FD|fd|PIL|pil)\s*([a-zA-Z]{1,2})\s*([0-9]{1,5})/gi
        var groups = fdRegex.exec(fdStr)
        if (!groups) {
          return null
        }
        var results = {
          gridType: groups[1].toUpperCase(),
          gridNorth: groups[2].toUpperCase(),
          gridEast: groups[3]
        }
        return results
      },

      getCenter: function() {
        return this.olmap.getView().getCenter();
      },

      // reusable tile loader hook to update a loading indicator
      tileLoaderHook: function (tileSource, tileLayer) {
        // number of tiles currently in flight
        var numLoadingTiles = 0
        // number of misses for the current set
        var badTiles = 0
        var tileLoader = tileSource.getTileLoadFunction()
        return function (tile, src) {
          if (numLoadingTiles === 0) {
            tileLayer.progress = 'loading'
            badTiles = 0
          }
          numLoadingTiles++
          var image = tile.getImage()
          // to hell with you, cross origin policy!
          image.crossOrigin = 'use-credentials'
          image.onload = function () {
            numLoadingTiles--
            if (numLoadingTiles === 0) {
              if (badTiles > 0) {
                tileLayer.progress = 'error'
              } else {
                tileLayer.progress = 'idle'
              }
            }
          }
          image.onerror = function () {
            badTiles++
            image.onload()
          }
          tileLoader(tile, src)
        }
      },
      // loader for layers with a "time" axis, e.g. live satellite imagery
      createTimelineLayer: function (options) {
        var vm = this
        options.params = $.extend({
          FORMAT: 'image/jpeg',
          SRS: 'EPSG:4326'
        }, options.params || {})

        // technically, we can specify a WMS source and a layer without
        // either the source URL or the layerID. which is good, because
        // we need to do that later on in a callback.
        var tileSource = new ol.source.TileWMS({
          params: options.params,
          tileGrid: new ol.tilegrid.TileGrid({
            extent: [-180, -90, 180, 90],
            resolutions: this.resolutions,
            tileSize: [1024, 1024]
          })
        })

        var tileLayer = new ol.layer.Tile({
          opacity: options.opacity || 1,
          source: tileSource
        })

        // hook the tile loading function to update progress indicator
        tileLayer.progress = ''
        tileSource.setTileLoadFunction(this.tileLoaderHook(tileSource, tileLayer))

        // hook to swap the tile layer when timeIndex changes
        tileLayer.on('propertychange', function (event) {
          if (event.key === 'timeIndex') {
            tileSource.updateParams({
              'layers': options.timeline[event.target.get(event.key)][1]
            })
          }
        })

        // helper function to update the time index
        options.updateTimeline = options.updateTimeline || function (layer,tileLayer) {
          // fetch the latest timestamp-to-layerID map from the source URL
          $.getJSON(layer.source, function (data) {
            tileLayer.set('updated', moment().toLocaleString())
            tileLayer.getSource().setUrls(data.servers)
            layer.timeline = data.layers.reverse()
            tileLayer.set('timeIndex', layer.timeIndex || layer.timeline.length - 1)
            vm.$root.active.update()
          })
        }

        options.updateTimeline(options,tileLayer)
        // if the "refresh" option is set, set a timer
        // to update the source
        if (options.refresh) {
          tileLayer.refresh = setInterval(function () {
            options.updateTimeline(options,tileLayer)
          }, options.refresh * 1000)
        }

        // set properties for use in layer selector
        tileLayer.set('name', options.name)
        tileLayer.set('id', options.id)
        return tileLayer
      },
      // loader for vector layers with hover querying
      createWFSLayer: function (options) {
        var vm = this
        var url = this.defaultWFSSrc
        // default overridable params sent to the WFS source
        options.params = $.extend({
          version: '1.1.0',
          service: 'WFS',
          request: 'GetFeature',
          outputFormat: 'application/json',
          srsname: 'EPSG:4326',
          typename: options.id
        }, options.params || {})

        var vectorSource = new ol.source.Vector()
        var vector = new ol.layer.Vector({
          opacity: options.opacity || 1,
          source: vectorSource,
          style: options.style
        })
        vector.progress = ''

        vectorSource.loadSource = function (loadType,onSuccess) {
          if (options.cql_filter) {
            options.params.cql_filter = options.cql_filter
          } else if (options.params.cql_filter) {
            delete options.params.cql_filter
          }
          vm.$root.active.refreshRevision += 1
          vector.progress = 'loading'
          $.ajax({
            url: url + '?' + $.param(options.params),
            success: function (response, stat, xhr) {
              var features = vm.$root.geojson.readFeatures(response)
              var defaultOnload = function(loadType,source,features) {
                  source.clear(true)
                  source.addFeatures(features)
              }
              if (options.onload) {
                options.onload(loadType,vectorSource,features,defaultOnload)
              } else {
                defaultOnload(loadType,vectorSource,features)
              }
              vm.$root.active.refreshRevision += 1
              vector.progress = 'idle'
              vector.set('updated', moment().toLocaleString())
              vectorSource.dispatchEvent('loadsource')
              if (onSuccess) {
                onSuccess()
              }
            },
            error: function () {
              vm.$root.active.refreshRevision += 1
              vector.progress = 'error'
            },
            dataType: 'json',
            xhrFields: {
              withCredentials: true
            }
          })
        }

        if (options.onadd) {
          vectorSource.on('addfeature', function (event) {
            options.onadd(event.feature)
          })
        }
        
        vector.postRemove = function () {
          // disable autoupdates
          if (this.autoRefresh) {
            clearInterval(this.autoRefresh)
            delete this.autoRefresh
          }
        }

        // if the "refresh" option is set, set a timer
        // to update the source
        if (options.refresh && !vector.autoRefresh) {
          vector.autoRefresh = setInterval(function () {
            vectorSource.loadSource("auto")
          }, options.refresh * 1000)
        }
        // populate the source with data
        vectorSource.loadSource("initial")

        vector.set('name', options.name)
        vector.set('id', options.id)

        vector.stopAutoRefresh = function() {
            if (this.autoRefresh) {
                clearInterval(this.autoRefresh)
                //console.log("Stop auto refresh for layer (" + options.id + ")")
                delete this.autoRefresh
            }
        }

        vector.startAutoRefresh = function() {
            if (!options.refresh) {
                //not refreshable
                return
            } 
            if(this.autoRefresh) {
                //already started
                return
            }
            this.autoRefresh = setInterval(function () {
                vectorSource.loadSource("auto")
            }, options.refresh * 1000)
            //console.log("Start auto refresh for layer (" + options.id + ") with interval " + options.refresh)
        }

        return vector
      },
      createAnnotations: function (layer) {
        return this.annotations.featureOverlay
      },
      // loader to create a WMTS layer from a kmi datasource
      createTileLayer: function (options) {
        var vm = this
        if (options.base) {
          options.format = 'image/jpeg'
        }
        var layer = $.extend({
          opacity: 1,
          name: 'Mapbox Outdoors',
          id: 'dpaw:mapbox_outdoors',
          format: 'image/png',
          tileSize: 1024,
          style: '',
          projection: 'EPSG:4326',
          wmts_url: this.defaultWMTSSrc
        }, options)

        // create a tile grid using the stock KMI resolutions
        var matrixSet = this.matrixSets[layer.projection][layer.tileSize]
        var tileGrid = new ol.tilegrid.WMTS({
          origin: ol.extent.getTopLeft([-180, -90, 180, 90]),
          resolutions: this.resolutions,
          matrixIds: matrixSet.matrixIds,
          tileSize: layer.tileSize
        })

        // override getZForResolution on tile grid object;
        // for weird zoom levels, the default is to round up or down to the
        // nearest integer to determine which tiles to use.
        // because we want the printing rasters to contain as much detail as
        // possible, we rig it here to always round up.
        tileGrid.origGetZForResolution = tileGrid.getZForResolution
        tileGrid.getZForResolution = function (resolution, optDirection) {
          return tileGrid.origGetZForResolution(resolution*1.4, -1)
        }

        // create a tile source
        var tileSource = new ol.source.WMTS({
          url: layer.wmts_url,
          layer: layer.id,
          matrixSet: matrixSet.name,
          format: layer.format,
          style: layer.style,
          projection: layer.projection,
          wrapX: true,
          tileGrid: tileGrid
        })

        var tileLayer = new ol.layer.Tile({
          opacity: layer.opacity || 1,
          source: tileSource
        })

        // hook the tile loading function to update progress indicator
        tileLayer.progress = ''
        tileSource.setTileLoadFunction(this.tileLoaderHook(tileSource, tileLayer))

        tileLayer.postRemove = function () {
          if (this.autoRefresh) {
            clearInterval(this.autoRefresh)
            delete this.autoRefresh
          }
          if (this.autoTimelineRefresh) {
            clearTimeout(this.autoTimelineRefresh)
            //console.log(momentTimezone().format() + " : Clear " + layer.id + "'s auto timeline refresh task. " )
            this.autoTimelineRefresh = null
          }
        }   

        // set properties for use in layer selector
        tileLayer.set('name', layer.name,false)
        tileLayer.set('id', layer.id,false)

        // hook to swap the tile layer when timeIndex changes
        tileLayer.on('propertychange', function (event) {
          if (event.key === 'timeIndex') {
            if (!(options.timeline[event.target.get(event.key)][2])) {
                options.timeline[event.target.get(event.key)][2] = new ol.source.WMTS({
                  url: layer.wmts_url,
                  layer: options.timeline[event.target.get(event.key)][1],
                  matrixSet: matrixSet.name,
                  format: layer.format,
                  style: layer.style,
                  projection: layer.projection,
                  wrapX: true,
                  tileGrid: tileGrid
                })
            }
            tileLayer.setSource(options.timeline[event.target.get(event.key)][2] )
          }
        })

        if (!options.updateTimeline && (options.getLatestUpdateTime || options.updateTime ) && options.getLayerId) {
            options.updateTimeline = function(){
                var _func = null
                var updateTime = null
                if (options.updateTime) {
                    if (!options.getLatestUpdateTime) {
                        $.each(options.updateTime[0],function(index,time) {
                            options.updateTime[0][index] = momentTimezone.tz(time,options.updateTime[1],options.updateTime[2]).format(options.updateTime[1])
                        })

                        options.getLatestUpdateTime = function() {
                            var now = momentTimezone().tz(options.updateTime[2])
                            var nowStr = now.format(options.updateTime[1])
                            var updateTimeIndex = null
                            $.each(options.updateTime[0],function(index,time) {
                                if (nowStr < time) {
                                    if (index === 0) {
                                        //latest update time is yesterday's last update point
                                        updateTimeIndex = -1
                                    } else {
                                        //latest update time is today's previous update point
                                        updateTimeIndex = index - 1
                                    }
                                    return false
                                } else if(nowStr === time) {
                                    //latest update time is today's current update point
                                    updateTimeIndex = index
                                    return false
                                }
                            })
                            var updateTime = null
                            if (updateTimeIndex === null) {
                                //latest update time is today's last update point
                                updateTime = momentTimezone.tz(options.updateTime[0][options.updateTime[0].length - 1],options.updateTime[1],options.updateTime[2])
                            } else if (updateTimeIndex === -1) {
                                updateTime = momentTimezone.tz(options.updateTime[0][options.updateTime[0].length - 1],options.updateTime[1],options.updateTime[2])
                                updateTime = updateTime.date(updateTime.date() - 1)
                            } else {
                                updateTime = momentTimezone.tz(options.updateTime[0][updateTimeIndex],options.updateTime[1],options.updateTime[2])
                            }
                            return updateTime.tz("Australia/Perth")
                        }
                        options.getNextUpdateTime = function() {
                            var now = momentTimezone().tz(options.updateTime[2])
                            var nowStr = now.format(options.updateTime[1])
                            var updateTimeIndex = null
                            $.each(options.updateTime[0],function(index,time) {
                                if (nowStr < time) {
                                    updateTimeIndex = index
                                    return false
                                } else if(nowStr === time) {
                                    if (index < options.updateTime[0].length - 1) {
                                        //next update time is today's next update point
                                        updateTimeIndex = index + 1
                                    } else  {
                                        //next update time is tomorrow's first update point
                                        updateTimeIndex = -1
                                    }
                                    return false
                                }
                            })
                            var updateTime = null
                            if (updateTimeIndex === null || updateTimeIndex === -1) {
                                //next update time is tomorrow's first update point
                                updateTime = momentTimezone.tz(options.updateTime[0][0],options.updateTime[1],options.updateTime[2])
                                updateTime = updateTime.date(updateTime.date() + 1)
                            } else {
                                updateTime = momentTimezone.tz(options.updateTime[0][updateTimeIndex],options.updateTime[1],options.updateTime[2])
                            }
                            return updateTime.tz("Australia/Perth")
                        }
                    }
                }
                _func = function(layer,tileLayer,auto) {
                    //console.log(momentTimezone().format() + " : update " + layer.id + "'s timeline. ")
                    if (tileLayer.autoTimelineRefresh) {
                        if (!auto) {
                            //console.log(momentTimezone().format() + " : Clear " + layer.id + "'s auto timeline refresh task. " )
                            clearTimeout(tileLayer.autoTimelineRefresh)
                        }
                        tileLayer.autoTimelineRefresh = null
                    }
                    
                    var latestUpdateTime = layer.getLatestUpdateTime()
                    if (!updateTime || latestUpdateTime - updateTime === 0) {
                        var layerTime = momentTimezone(latestUpdateTime)
                        var layerId = null
                        if (layer.timeline) {
                            for(var i = 0;i < layer.timelineSize; i++) {
                                layerId = layer.getLayerId(latestUpdateTime,i)
                                if (layer.layerTimeInterval) {
                                    layer.timeline[i][0] = layerTime.format() + " (" + layerId + ")"
                                    layerTime = momentTimezone(layerTime + layer.layerTimeInterval)
                                } else if (layer.getLayerTime){
                                    layer.timeline[i][0] = layer.getLayerTime(latestUpdateTime,i) + " (" + layerId + ")"
                                } else {
                                    layer.timeline[i][0] = i + " (" + layerId + ")"
                                }
                                if (layerId !== layer.timeline[i][1]) {
                                    layer.timeline[i][2] = null
                                }
                            }
                        } else {
                            layer.timeline=[]
                            var layerTitle = null
                            for(var i = 0;i < layer.timelineSize; i++) {
                                layerId = layer.getLayerId(latestUpdateTime,i)
                                if (layer.layerTimeInterval) {
                                    layerTitle = layerTime.format() + " (" + layerId + ")"
                                    layerTime = momentTimezone(layerTime + layer.layerTimeInterval).tz("Australia/Perth")
                                } else if (layer.getLayerTime){
                                    layerTitle = layer.getLayerTime(latestUpdateTime,i) + " (" + layerId + ")"
                                } else {
                                    layerTitle = i + " (" + layerId + ")"
                                }
                                layer.timeline.push([layerTitle,layerId,null])
                            }
                        }
        
                        var timeIndex = null
                        if (layer.layerTimeInterval) {
                            if (updateTime && tileLayer.get('timeIndex')) {
                                timeIndex = tileLayer.get('timeIndex') - ((latestUpdateTime - updateTime) / layer.layerTimeInterval)
                                if (timeIndex < 0) {
                                    timeIndex = null
                                }
                            } 
                        }
                        var now = momentTimezone().tz("Australia/Perth")
                        if (layer.layerTimeInterval) {
                            if (!timeIndex) {
                                timeIndex = parseInt((now - latestUpdateTime) / layer.layerTimeInterval)
                            }
                        }
                        tileLayer.set('timeIndex', timeIndex || 0)
                            
                        updateTime = latestUpdateTime
                        tileLayer.set('updated',latestUpdateTime.format())
                        vm.active.refreshRevision += 1
                    }

                    if (layer.previewLayer) {return}

                    //delay 10 seconds to update timeline
                    var waitTimes = layer.getNextUpdateTime() - momentTimezone().tz("Australia/Perth") + 10000
                    //console.log(momentTimezone().format() + " : Wait " + waitTimes / 3600000 + " hours to refresh " + layer.id + "'s timeline.")
                    tileLayer.autoTimelineRefresh = setTimeout(function(){_func(layer,tileLayer,true)},waitTimes)
                }
                
                return _func
           }()
        }

        if (options.updateTimeline) {
            options.updateTimeline(options,tileLayer)
            // if the "refresh" option is set, set a timer
            // to update the source
            if (options.timelineRefresh) {
              tileLayer.autoTimelineRefresh = setInterval(function () {
                options.updateTimeline(options,tileLayer)
              }, options.timelineRefresh * 1000)
            }
        }

        var setUrlTimestamp = function() {
            var originFunc = tileSource.getTileUrlFunction()
            return function(time) {
                tileLayer.getSource().setTileUrlFunction(function(tileCoord,pixelRatio,projection){
                    return originFunc(tileCoord,pixelRatio,projection) + "&time=" + time
                },tileSource.getUrls()[0] + "?time=" + time)
            }
        }()

        // if the "refresh" option is set, set a timer
        // to force a reload of the tile content
        if (layer.refresh) {
          tileLayer.set('updated', moment().toLocaleString())
          vm.$root.active.refreshRevision += 1
          tileSource.load = function() {
            tileLayer.set('updated', moment().toLocaleString())
            setUrlTimestamp(moment.utc().unix())
            vm.$root.active.refreshRevision += 1
          }
          tileLayer.autoRefresh = setInterval(function () {
            tileSource.load()
          }, layer.refresh * 1000)
        }

        tileLayer.stopAutoRefresh = function() {
            if (this.autoRefresh) {
                clearInterval(this.autoRefresh)
                //console.log("Stop auto refresh for layer (" + layer.id + ")")
                delete this.autoRefresh
            }
        }

        tileLayer.startAutoRefresh = function() {
            if (!layer.refresh) {
                //not refreshable
                return
            } 
            if(this.autoRefresh) {
                //already started
                return
            }
            this.autoRefresh = setInterval(function () {
                tileSource.load()
            }, layer.refresh * 1000)
            //console.log("Start auto refresh for layer (" + layer.id + ") with interval " + layer.refresh)
        }


        return tileLayer
      },

      getMapLayer: function (id) {
        if (!this.olmap) { return undefined}
        if (id && id.id) { id = id.id } // if passed a catalogue layer, get actual id
        return this.olmap.getLayers().getArray().find(function (layer) {
          return layer.get('id') === id
        })
      },
      // initialise map
      init: function (options) {
        var vm = this
        options = options || {}

        // add some extra projections
        proj4.defs("EPSG:28349","+proj=utm +zone=49 +south +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");
        proj4.defs("EPSG:28350","+proj=utm +zone=50 +south +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");
        proj4.defs("EPSG:28351","+proj=utm +zone=51 +south +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");
        proj4.defs("EPSG:28352","+proj=utm +zone=52 +south +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");
        proj4.defs("EPSG:28353","+proj=utm +zone=53 +south +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");
        proj4.defs("EPSG:28354","+proj=utm +zone=54 +south +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");
        proj4.defs("EPSG:28355","+proj=utm +zone=55 +south +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");
        proj4.defs("EPSG:28356","+proj=utm +zone=56 +south +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");

        // bump search bar over if there's no fullscreen button
        if (!ol.control.FullScreen.isFullScreenSupported()) {
          $('#map-search').addClass('noFullScreen')
          $('#map-search-button').addClass('noFullScreen')
        }

        this.olmap = new ol.Map({
          logo: false,
          renderer: 'canvas',
          target: 'map',
          view: new ol.View({
            projection: 'EPSG:4326',
            center: vm.view.center,
            zoom: 6,
            maxZoom: 21,
            minZoom: 5
          }),
          controls:[],
          interactions: ol.interaction.defaults({
            altShiftDragRotate: false,
            pinchRotate: false,
            dragPan: false,
            doubleClickZoom: false,
            keyboard: false
          })
        })

        vm.mapControls = {
            "zoom": {
                enabled:false,
                controls:new ol.control.Zoom({
                  target: $('#external-controls').get(0)   
                })
            },
            "scaleLine": {
                enabled:false,
                controls:new ol.control.ScaleLine()
            },
            "mousePosition": {
                enabled:false,
                controls:new ol.control.MousePosition({
                    coordinateFormat: function(coordinate) {
                        return vm.getDeg(coordinate)+'<br/>'+vm.getDMS(coordinate)+'<br/>'+vm.getMGA(coordinate)
                    }
                })
            },
            "fullScreen": {
                enabled:false,
                controls:new ol.control.FullScreen({
                    source: $('body').get(0),
                    target: $('#external-controls').get(0),
                    label: $('<i/>', {
                        class: 'fa fa-expand'
                    })[0]
                })
            },
            "scale": {
                enabled:false,
                controls:new ol.control.Control({
                    element: $('#menu-scale').get(0),
                    target: $('#external-controls').get(0)
            })},
            "search": {
                enabled:false,
                controls: [
                    new ol.control.Control({
                        element: $('#map-search').get(0),
                        target: $('#external-controls').get(0)
                      }),
                    new ol.control.Control({
                        element: $('#map-search-button').get(0),
                        target: $('#external-controls').get(0)
                    })
                ]
            },
            "attribution": {
                enabled:false,
                controls:new ol.control.Attribution()
            },
            "measure": {
                enabled:false,
                controls:vm.measure.mapControl
            }
        }
        $.each(vm.mapControls,function(key,control){
            vm.enableControl(key,true)
        })

        this.setScale(this.view.scale / 1000)

        // add some default interactions
        this.olmap.addInteraction(this.dragPanInter)
        this.olmap.addInteraction(this.doubleClickZoomInter)
        this.olmap.addInteraction(this.keyboardPanInter)
        this.olmap.addInteraction(this.keyboardZoomInter)
        this.olmap.addInteraction(this.middleDragPanInter)

        // Create the graticule component
        this.graticule.setMap(this.olmap)

        // setup scale events
        this.olmap.on('postrender', function () {
          vm.scale = vm.getScale()
        })

      },
      initLayers: function (fixedLayers, activeLayers) {
        var vm = this
        //add fixed layers to category
        $.each(fixedLayers,function(index,fixedLayer) {
            var catLayer = vm.$root.catalogue.getLayer(fixedLayer.id)
            if (catLayer) {
                //fixed layer already exist, update the properties 
                $.extend(catLayer,fixedLayer)
            } else {
                //fixed layer not exist, add it
                vm.$root.catalogue.catalogue.push(fixedLayer)
            }
        })
        //ignore the active layers which does not exist in the catalogue layers.
        activeLayers = activeLayers.filter(function(activeLayer){
            return vm.$root.catalogue.getLayer(activeLayer[0]) && true
        })
        //create active open layers 
        var initialLayers = activeLayers.reverse().map(function (activeLayer) {
          var layer = $.extend(vm.$root.catalogue.getLayer(activeLayer[0]), activeLayer[1])
          return vm['create' + layer.type](layer)
        })
        //add active layers into map
        $.each(initialLayers,function(index,layer){
            vm.olmap.addLayer(layer)
        })
      }
    },
    ready: function () {
      var mapStatus = this.loading.register("olmap","Open layer map Component","Initialize")
      this.svgBlobs = {}
      this.svgTemplates = {}
      this.cachedStyles = {}
      this.jobs = {}

      // generate matrix IDs from name and level number
      $.each(this.matrixSets, function (projection, innerMatrixSets) {
        $.each(innerMatrixSets, function (tileSize, matrixSet) {
          var matrixIds = new Array(matrixSet.maxLevel - matrixSet.minLevel + 1)
          for (var z = matrixSet.minLevel; z <= matrixSet.maxLevel; ++z) {
            matrixIds[z] = matrixSet.name + ':' + z
          }
          matrixSet.matrixIds = matrixIds
        })
      })
      mapStatus.end()
    }
  }
</script>
